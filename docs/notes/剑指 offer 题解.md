* [點擊閱讀面試進階指南 ](https://github.com/CyC2018/Backend-Interview-Guide)
<!-- GFM-TOC -->
* [3. 數組中重復的數字](#3-數組中重復的數字)
* [4. 二維數組中的查找](#4-二維數組中的查找)
* [5. 替換空格](#5-替換空格)
* [6. 從尾到頭打印鏈表](#6-從尾到頭打印鏈表)
* [7. 重建二叉樹](#7-重建二叉樹)
* [8. 二叉樹的下一個結點](#8-二叉樹的下一個結點)
* [9. 用兩個棧實現隊列](#9-用兩個棧實現隊列)
* [10.1 斐波那契數列](#101-斐波那契數列)
* [10.2 跳台階](#102-跳台階)
* [10.3 矩形覆蓋](#103-矩形覆蓋)
* [10.4 變態跳台階](#104-變態跳台階)
* [11. 旋轉數組的最小數字](#11-旋轉數組的最小數字)
* [12. 矩陣中的路徑](#12-矩陣中的路徑)
* [13. 機器人的運動範圍](#13-機器人的運動範圍)
* [14. 剪繩子](#14-剪繩子)
* [15. 二進制中 1 的個數](#15-二進制中-1-的個數)
* [16. 數值的整數次方](#16-數值的整數次方)
* [17. 打印從 1 到最大的 n 位數](#17-打印從-1-到最大的-n-位數)
* [18.1 在 O(1) 時間內刪除鏈表節點](#181-在-o1-時間內刪除鏈表節點)
* [18.2 刪除鏈表中重復的結點](#182-刪除鏈表中重復的結點)
* [19. 正則表達式匹配](#19-正則表達式匹配)
* [20. 表示數值的字符串](#20-表示數值的字符串)
* [21. 調整數組順序使奇數位於偶數前面](#21-調整數組順序使奇數位於偶數前面)
* [22. 鏈表中倒數第 K 個結點](#22-鏈表中倒數第-k-個結點)
* [23. 鏈表中環的入口結點](#23-鏈表中環的入口結點)
* [24. 反轉鏈表](#24-反轉鏈表)
* [25. 合並兩個排序的鏈表](#25-合並兩個排序的鏈表)
* [26. 樹的子結構](#26-樹的子結構)
* [27. 二叉樹的鏡像](#27-二叉樹的鏡像)
* [28 對稱的二叉樹](#28-對稱的二叉樹)
* [29. 順時針打印矩陣](#29-順時針打印矩陣)
* [30. 包含 min 函數的棧](#30-包含-min-函數的棧)
* [31. 棧的壓入、彈出序列](#31-棧的壓入彈出序列)
* [32.1 從上往下打印二叉樹](#321-從上往下打印二叉樹)
* [32.2 把二叉樹打印成多行](#322-把二叉樹打印成多行)
* [32.3 按之字形順序打印二叉樹](#323-按之字形順序打印二叉樹)
* [33. 二叉搜索樹的後序遍歷序列](#33-二叉搜索樹的後序遍歷序列)
* [34. 二叉樹中和為某一值的路徑](#34-二叉樹中和為某一值的路徑)
* [35. 復雜鏈表的復制](#35-復雜鏈表的復制)
* [36. 二叉搜索樹與雙向鏈表](#36-二叉搜索樹與雙向鏈表)
* [37. 序列化二叉樹](#37-序列化二叉樹)
* [38. 字符串的排列](#38-字符串的排列)
* [39. 數組中出現次數超過一半的數字](#39-數組中出現次數超過一半的數字)
* [40. 最小的 K 個數](#40-最小的-k-個數)
* [41.1 數據流中的中位數](#411-數據流中的中位數)
* [41.2 字符流中第一個不重復的字符](#412-字符流中第一個不重復的字符)
* [42. 連續子數組的最大和](#42-連續子數組的最大和)
* [43. 從 1 到 n 整數中 1 出現的次數](#43-從-1-到-n-整數中-1-出現的次數)
* [44. 數字序列中的某一位數字](#44-數字序列中的某一位數字)
* [45. 把數組排成最小的數](#45-把數組排成最小的數)
* [46. 把數字翻譯成字符串](#46-把數字翻譯成字符串)
* [47. 禮物的最大價值](#47-禮物的最大價值)
* [48. 最長不含重復字符的子字符串](#48-最長不含重復字符的子字符串)
* [49. 醜數](#49-醜數)
* [50. 第一個只出現一次的字符位置](#50-第一個只出現一次的字符位置)
* [51. 數組中的逆序對](#51-數組中的逆序對)
* [52. 兩個鏈表的第一個公共結點](#52-兩個鏈表的第一個公共結點)
* [53. 數字在排序數組中出現的次數](#53-數字在排序數組中出現的次數)
* [54. 二叉查找樹的第 K 個結點](#54-二叉查找樹的第-k-個結點)
* [55.1 二叉樹的深度](#551-二叉樹的深度)
* [55.2 平衡二叉樹](#552-平衡二叉樹)
* [56. 數組中只出現一次的數字](#56-數組中只出現一次的數字)
* [57.1 和為 S 的兩個數字](#571-和為-s-的兩個數字)
* [57.2 和為 S 的連續正數序列](#572-和為-s-的連續正數序列)
* [58.1 翻轉單詞順序列](#581-翻轉單詞順序列)
* [58.2 左旋轉字符串](#582-左旋轉字符串)
* [59. 滑動窗口的最大值](#59-滑動窗口的最大值)
* [60. n 個骰子的點數](#60-n-個骰子的點數)
* [61. 撲克牌順子](#61-撲克牌順子)
* [62. 圓圈中最後剩下的數](#62-圓圈中最後剩下的數)
* [63. 股票的最大利潤](#63-股票的最大利潤)
* [64. 求 1+2+3+...+n](#64-求-123n)
* [65. 不用加減乘除做加法](#65-不用加減乘除做加法)
* [66. 構建乘積數組](#66-構建乘積數組)
* [67. 把字符串轉換成整數](#67-把字符串轉換成整數)
* [68. 樹中兩個節點的最低公共祖先](#68-樹中兩個節點的最低公共祖先)
* [參考文獻](#參考文獻)
<!-- GFM-TOC -->


部分繪圖文件可以在這裡免費下載：[劍指 Offer](https://www.processon.com/view/5a3e4c7be4b0909c1aa18b49)，後續會慢慢把所有題目都配上 GIF 演示圖。

# 3. 數組中重復的數字

[NowCoder](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

在一個長度為 n 的數組裡的所有數字都在 0 到 n-1 的範圍內。數組中某些數字是重復的，但不知道有幾個數字是重復的，也不知道每個數字重復幾次。請找出數組中任意一個重復的數字。

```html
Input:
{2, 3, 1, 0, 2, 5}

Output:
2
```

## 解題思路

要求是時間復雜度 O(N)，空間復雜度 O(1)。因此不能使用排序的方法，也不能使用額外的標記數組。

對於這種數組元素在 [0, n-1] 範圍內的問題，可以將值為 i 的元素調整到第 i 個位置上進行求解。

以 (2, 3, 1, 0, 2, 5) 為例，遍歷到位置 4 時，該位置上的數為 2，但是第 2 個位置上已經有一個 2 的值了，因此可以知道 2 重復：

<div align="center"> <img src="pics/_u6570_u7EC4_u4E2D_u91CD_u590D_1548260392361.gif" width="250px"> </div><br>

```java
public boolean duplicate(int[] nums, int length, int[] duplication) {
    if (nums == null || length <= 0)
        return false;
    for (int i = 0; i < length; i++) {
        while (nums[i] != i) {
            if (nums[i] == nums[nums[i]]) {
                duplication[0] = nums[i];
                return true;
            }
            swap(nums, i, nums[i]);
        }
    }
    return false;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

# 4. 二維數組中的查找

[NowCoder](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

給定一個二維數組，其每一行從左到右遞增排序，從上到下也是遞增排序。給定一個數，判斷這個數是否在該二維數組中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

## 解題思路

要求時間復雜度 O(M + N)，空間復雜度 O(1)。

該二維數組中的一個數，它左邊的數都比它小，下邊的數都比它大。因此，從右上角開始查找，就可以根據 target 和當前元素的大小關系來縮小查找區間，當前元素的查找區間為左下角的所有元素。

<div align="center"> <img src="pics/_u4E8C_u7EF4_u6570_u7EC4_u4E2D_.gif"/> </div><br>

```java
public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return false;
    int rows = matrix.length, cols = matrix[0].length;
    int r = 0, c = cols - 1; // 從右上角開始
    while (r <= rows - 1 && c >= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target > matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}
```

# 5. 替換空格

[NowCoder](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述


將一個字符串中的空格替換成 "%20"。

```text
Input:
"A B"

Output:
"A%20B"
```

## 解題思路

在字符串尾部填充任意字符，使得字符串的長度等於替換之後的長度。因為一個空格要替換成三個字符（%20），因此當遍歷到一個空格時，需要在尾部填充兩個任意字符。

令 P1 指向字符串原來的末尾位置，P2 指向字符串現在的末尾位置。P1 和 P2 從後向前遍歷，當 P1 遍歷到一個空格時，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否則就填充上 P1 指向字符的值。

從後向前遍是為了在改變 P2 所指向的內容時，不會影響到 P1 遍歷原來字符串的內容。

<div align="center"> <img src="pics/_u66FF_u6362_u7A7A_u683C.gif"/> </div><br>

```java
public String replaceSpace(StringBuffer str) {
    int P1 = str.length() - 1;
    for (int i = 0; i <= P1; i++)
        if (str.charAt(i) == ' ')
            str.append("  ");

    int P2 = str.length() - 1;
    while (P1 >= 0 && P2 > P1) {
        char c = str.charAt(P1--);
        if (c == ' ') {
            str.setCharAt(P2--, '0');
            str.setCharAt(P2--, '2');
            str.setCharAt(P2--, '%');
        } else {
            str.setCharAt(P2--, c);
        }
    }
    return str.toString();
}
```

# 6. 從尾到頭打印鏈表

[NowCoder](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

從尾到頭反過來打印出每個結點的值。

<div align="center"> <img src="pics/_u4ECE_u5C3E_u5230_u5934_u6253_1548293972480.gif" width="250px"> </div><br>

## 解題思路

### 使用遞歸

<div align="center"> <img src="pics/_u4ECE_u5C3E_u5230_u5934_u6253_1548296249372.gif" width="200px"> </div><br>

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    ArrayList<Integer> ret = new ArrayList<>();
    if (listNode != null) {
        ret.addAll(printListFromTailToHead(listNode.next));
        ret.add(listNode.val);
    }
    return ret;
}
```

### 使用頭插法

利用鏈表頭插法為逆序的特點。

頭結點和第一個節點的區別：

- 頭結點是在頭插法中使用的一個額外節點，這個節點不存儲值；
- 第一個節點就是鏈表的第一個真正存儲值的節點。

<div align="center"> <img src="pics/_u4ECE_u5C3E_u5230_u5934_u6253_1548295232667.gif" width="300px"> </div><br>

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    // 頭插法構建逆序鏈表
    ListNode head = new ListNode(-1);
    while (listNode != null) {
        ListNode memo = listNode.next;
        listNode.next = head.next;
        head.next = listNode;
        listNode = memo;
    }
    // 構建 ArrayList
    ArrayList<Integer> ret = new ArrayList<>();
    head = head.next;
    while (head != null) {
        ret.add(head.val);
        head = head.next;
    }
    return ret;
}
```

### 使用棧

<div align="center"> <img src="pics/_u4ECE_u5C3E_u5230_u5934_u6253_1548503461113.gif" width="500px"> </div><br>

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    Stack<Integer> stack = new Stack<>();
    while (listNode != null) {
        stack.add(listNode.val);
        listNode = listNode.next;
    }
    ArrayList<Integer> ret = new ArrayList<>();
    while (!stack.isEmpty())
        ret.add(stack.pop());
    return ret;
}
```

# 7. 重建二叉樹

[NowCoder](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

根據二叉樹的前序遍歷和中序遍歷的結果，重建出該二叉樹。假設輸入的前序遍歷和中序遍歷的結果中都不含重復的數字。

```html
preorder = [3,9,20,15,7]
inorder =  [9,3,15,20,7]
```

<div align="center"> <img src="pics/_u91CD_u5EFA_u4E8C_u53C9_u6811-1.gif" width="200"/> </div><br>

## 解題思路

前序遍歷的第一個值為根節點的值，使用這個值將中序遍歷結果分成兩部分，左部分為樹的左子樹中序遍歷結果，右部分為樹的右子樹中序遍歷的結果。

<div align="center"> <img src="pics/_u91CD_u5EFA_u4E8C_u53C9_u6811-21548502782193.gif"/> </div><br>

```java
// 緩存中序遍歷數組每個值對應的索引
private Map<Integer, Integer> indexForInOrders = new HashMap<>();

public TreeNode reConstructBinaryTree(int[] pre, int[] in) {
    for (int i = 0; i < in.length; i++)
        indexForInOrders.put(in[i], i);
    return reConstructBinaryTree(pre, 0, pre.length - 1, 0);
}

private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL) {
    if (preL > preR)
        return null;
    TreeNode root = new TreeNode(pre[preL]);
    int inIndex = indexForInOrders.get(root.val);
    int leftTreeSize = inIndex - inL;
    root.left = reConstructBinaryTree(pre, preL + 1, preL + leftTreeSize, inL);
    root.right = reConstructBinaryTree(pre, preL + leftTreeSize + 1, preR, inL + leftTreeSize + 1);
    return root;
}
```

# 8. 二叉樹的下一個結點

[NowCoder](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

給定一個二叉樹和其中的一個結點，請找出中序遍歷順序的下一個結點並且返回。注意，樹中的結點不僅包含左右子結點，同時包含指向父結點的指針。

```java
public class TreeLinkNode {

    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
```

## 解題思路

① 如果一個節點的右子樹不為空，那麼該節點的下一個節點是右子樹的最左節點；

<div align="center"> <img src="pics/_u4E8C_u53C9_u6811_u7684_u4E0B_.gif" width="250"/> </div><br>

② 否則，向上找第一個左鏈接指向的樹包含該節點的祖先節點。

<div align="center"> <img src="pics/_u4E8C_u53C9_u6811_u7684_u4E0B_1548504426508.gif" width="250"/> </div><br>

```java
public TreeLinkNode GetNext(TreeLinkNode pNode) {
    if (pNode.right != null) {
        TreeLinkNode node = pNode.right;
        while (node.left != null)
            node = node.left;
        return node;
    } else {
        while (pNode.next != null) {
            TreeLinkNode parent = pNode.next;
            if (parent.left == pNode)
                return parent;
            pNode = pNode.next;
        }
    }
    return null;
}
```

# 9. 用兩個棧實現隊列

[NowCoder](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

用兩個棧來實現一個隊列，完成隊列的 Push 和 Pop 操作。

## 解題思路

in 棧用來處理入棧（push）操作，out 棧用來處理出棧（pop）操作。一個元素進入 in 棧之後，出棧的順序被反轉。當元素要出棧時，需要先進入 out 棧，此時元素出棧順序再一次被反轉，因此出棧順序就和最開始入棧順序是相同的，先進入的元素先退出，這就是隊列的順序。

<div align="center"> <img src="pics/_u7528_u4E24_u4E2A_u6808_u5B9E_.gif" width="500"/> </div><br>


```java
Stack<Integer> in = new Stack<Integer>();
Stack<Integer> out = new Stack<Integer>();

public void push(int node) {
    in.push(node);
}

public int pop() throws Exception {
    if (out.isEmpty())
        while (!in.isEmpty())
            out.push(in.pop());

    if (out.isEmpty())
        throw new Exception("queue is empty");

    return out.pop();
}
```

# 10.1 斐波那契數列

[NowCoder](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

求斐波那契數列的第 n 項，n <= 39。

<div align="center"><img src="https://latex.codecogs.com/gif.latex?f(n)=\left\{\begin{array}{rcl}0&&{n=0}\\1&&{n=1}\\f(n-1)+f(n-2)&&{n>1}\end{array}\right."/></div> <br>

## 解題思路

如果使用遞歸求解，會重復計算一些子問題。例如，計算 f(10) 需要計算 f(9) 和 f(8)，計算 f(9) 需要計算 f(8) 和 f(7)，可以看到 f(8) 被重復計算了。

<div align="center"> <img src="pics/_u6590_u6CE2_u90A3_u5951_u6570_u5217.gif" width="400"/> </div><br>


遞歸是將一個問題劃分成多個子問題求解，動態規劃也是如此，但是動態規劃會把子問題的解緩存起來，從而避免重復求解子問題。

```java
public int Fibonacci(int n) {
    if (n <= 1)
        return n;
    int[] fib = new int[n + 1];
    fib[1] = 1;
    for (int i = 2; i <= n; i++)
        fib[i] = fib[i - 1] + fib[i - 2];
    return fib[n];
}
```

考慮到第 i 項只與第 i-1 和第 i-2 項有關，因此只需要存儲前兩項的值就能求解第 i 項，從而將空間復雜度由 O(N) 降低為 O(1)。

```java
public int Fibonacci(int n) {
    if (n <= 1)
        return n;
    int pre2 = 0, pre1 = 1;
    int fib = 0;
    for (int i = 2; i <= n; i++) {
        fib = pre2 + pre1;
        pre2 = pre1;
        pre1 = fib;
    }
    return fib;
}
```

由於待求解的 n 小於 40，因此可以將前 40 項的結果先進行計算，之後就能以 O(1) 時間復雜度得到第 n 項的值了。

```java
public class Solution {

    private int[] fib = new int[40];

    public Solution() {
        fib[1] = 1;
        fib[2] = 2;
        for (int i = 2; i < fib.length; i++)
            fib[i] = fib[i - 1] + fib[i - 2];
    }

    public int Fibonacci(int n) {
        return fib[n];
    }
}
```

# 10.2 跳台階

[NowCoder](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

一只青蛙一次可以跳上 1 級台階，也可以跳上 2 級。求該青蛙跳上一個 n 級的台階總共有多少種跳法。

<div align="center"> <img src="pics/1_2001550465428749.png"/> </div><br>

## 解題思路

```java
public int JumpFloor(int n) {
    if (n <= 2)
        return n;
    int pre2 = 1, pre1 = 2;
    int result = 1;
    for (int i = 2; i < n; i++) {
        result = pre2 + pre1;
        pre2 = pre1;
        pre1 = result;
    }
    return result;
}
```

# 10.3 矩形覆蓋

[NowCoder](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

我們可以用 2\*1 的小矩形橫著或者豎著去覆蓋更大的矩形。請問用 n 個 2\*1 的小矩形無重疊地覆蓋一個 2\*n 的大矩形，總共有多少種方法？

<div align="center"> <img src="pics/11550465817827.gif"/> </div><br>

## 解題思路

```java
public int RectCover(int n) {
    if (n <= 2)
        return n;
    int pre2 = 1, pre1 = 2;
    int result = 0;
    for (int i = 3; i <= n; i++) {
        result = pre2 + pre1;
        pre2 = pre1;
        pre1 = result;
    }
    return result;
}
```

# 10.4 變態跳台階

[NowCoder](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

一只青蛙一次可以跳上 1 級台階，也可以跳上 2 級... 它也可以跳上 n 級。求該青蛙跳上一個 n 級的台階總共有多少種跳法。

<div align="center"> <img src="pics/21550465890674.gif"/> </div><br>

## 解題思路

### 動態規劃

```java
public int JumpFloorII(int target) {
    int[] dp = new int[target];
    Arrays.fill(dp, 1);
    for (int i = 1; i < target; i++)
        for (int j = 0; j < i; j++)
            dp[i] += dp[j];
    return dp[target - 1];
}
```

### 數學推導

跳上 n-1 級台階，可以從 n-2 級跳 1 級上去，也可以從 n-3 級跳 2 級上去...，那麼

```
f(n-1) = f(n-2) + f(n-3) + ... + f(0)
```

同樣，跳上 n 級台階，可以從 n-1 級跳 1 級上去，也可以從 n-2 級跳 2 級上去... ，那麼

```
f(n) = f(n-1) + f(n-2) + ... + f(0)
```

綜上可得

```
f(n) - f(n-1) = f(n-1)
```

即

```
f(n) = 2*f(n-1)
```

所以 f(n) 是一個等比數列

```source-java
public int JumpFloorII(int target) {
    return (int) Math.pow(2, target - 1);
}
```


# 11. 旋轉數組的最小數字

[NowCoder](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

把一個數組最開始的若干個元素搬到數組的末尾，我們稱之為數組的旋轉。輸入一個非遞減排序的數組的一個旋轉，輸出旋轉數組的最小元素。

例如數組 {3, 4, 5, 1, 2} 為 {1, 2, 3, 4, 5} 的一個旋轉，該數組的最小值為 1。

## 解題思路

在一個有序數組中查找一個元素可以用二分查找，二分查找也稱為折半查找，每次都能將查找區間減半，這種折半特性的算法時間復雜度都為 O(logN)。

本題可以修改二分查找算法進行求解：

- 當 nums[m] <= nums[h] 的情況下，說明解在 [l, m] 之間，此時令 h = m；
- 否則解在 [m + 1, h] 之間，令 l = m + 1。

```java
public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] <= nums[h])
            h = m;
        else
            l = m + 1;
    }
    return nums[l];
}
```

如果數組元素允許重復的話，那麼就會出現一個特殊的情況：nums[l] == nums[m] == nums[h]，那麼此時無法確定解在哪個區間，需要切換到順序查找。例如對於數組 {1,1,1,0,1}，l、m 和 h 指向的數都為 1，此時無法知道最小數字 0 在哪個區間。

```java
public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[l] == nums[m] && nums[m] == nums[h])
            return minNumber(nums, l, h);
        else if (nums[m] <= nums[h])
            h = m;
        else
            l = m + 1;
    }
    return nums[l];
}

private int minNumber(int[] nums, int l, int h) {
    for (int i = l; i < h; i++)
        if (nums[i] > nums[i + 1])
            return nums[i + 1];
    return nums[l];
}
```

# 12. 矩陣中的路徑

[NowCoder](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

請設計一個函數，用來判斷在一個矩陣中是否存在一條包含某字符串所有字符的路徑。路徑可以從矩陣中的任意一個格子開始，每一步可以在矩陣中向左，向右，向上，向下移動一個格子。如果一條路徑經過了矩陣中的某一個格子，則該路徑不能再進入該格子。

例如下面的矩陣包含了一條 bfce 路徑。

<div align="center"> <img src="pics/2_2001550466182933.png"/> </div><br>

## 解題思路

```java
private final static int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
private int rows;
private int cols;

public boolean hasPath(char[] array, int rows, int cols, char[] str) {
    if (rows == 0 || cols == 0)
        return false;
    this.rows = rows;
    this.cols = cols;
    boolean[][] marked = new boolean[rows][cols];
    char[][] matrix = buildMatrix(array);
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            if (backtracking(matrix, str, marked, 0, i, j))
                return true;
    return false;
}

private boolean backtracking(char[][] matrix, char[] str, boolean[][] marked, int pathLen, int r, int c) {
    if (pathLen == str.length)
        return true;
    if (r < 0 || r >= rows || c < 0 || c >= cols || matrix[r][c] != str[pathLen] || marked[r][c])
        return false;
    marked[r][c] = true;
    for (int[] n : next)
        if (backtracking(matrix, str, marked, pathLen + 1, r + n[0], c + n[1]))
            return true;
    marked[r][c] = false;
    return false;
}

private char[][] buildMatrix(char[] array) {
    char[][] matrix = new char[rows][cols];
    for (int i = 0, idx = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            matrix[i][j] = array[idx++];
    return matrix;
}
```

# 13. 機器人的運動範圍

[NowCoder](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

地上有一個 m 行和 n 列的方格。一個機器人從坐標 (0, 0) 的格子開始移動，每一次只能向左右上下四個方向移動一格，但是不能進入行坐標和列坐標的數位之和大於 k 的格子。

例如，當 k 為 18 時，機器人能夠進入方格 (35,37)，因為 3+5+3+7=18。但是，它不能進入方格 (35,38)，因為 3+5+3+8=19。請問該機器人能夠達到多少個格子？

## 解題思路

```java
private static final int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
private int cnt = 0;
private int rows;
private int cols;
private int threshold;
private int[][] digitSum;

public int movingCount(int threshold, int rows, int cols) {
    this.rows = rows;
    this.cols = cols;
    this.threshold = threshold;
    initDigitSum();
    boolean[][] marked = new boolean[rows][cols];
    dfs(marked, 0, 0);
    return cnt;
}

private void dfs(boolean[][] marked, int r, int c) {
    if (r < 0 || r >= rows || c < 0 || c >= cols || marked[r][c])
        return;
    marked[r][c] = true;
    if (this.digitSum[r][c] > this.threshold)
        return;
    cnt++;
    for (int[] n : next)
        dfs(marked, r + n[0], c + n[1]);
}

private void initDigitSum() {
    int[] digitSumOne = new int[Math.max(rows, cols)];
    for (int i = 0; i < digitSumOne.length; i++) {
        int n = i;
        while (n > 0) {
            digitSumOne[i] += n % 10;
            n /= 10;
        }
    }
    this.digitSum = new int[rows][cols];
    for (int i = 0; i < this.rows; i++)
        for (int j = 0; j < this.cols; j++)
            this.digitSum[i][j] = digitSumOne[i] + digitSumOne[j];
}
```

# 14. 剪繩子

[Leetcode](https://leetcode.com/problems/integer-break/description/)

## 題目描述

把一根繩子剪成多段，並且使得每段的長度乘積最大。

```html
n = 2
return 1 (2 = 1 + 1)

n = 10
return 36 (10 = 3 + 3 + 4)
```

## 解題思路

### 貪心

盡可能多剪長度為 3 的繩子，並且不允許有長度為 1 的繩子出現。如果出現了，就從已經切好長度為 3 的繩子中拿出一段與長度為 1 的繩子重新組合，把它們切成兩段長度為 2 的繩子。

證明：當 n >= 5 時，3(n - 3) - n = 2n - 9 > 0，且 2(n - 2) - n = n - 4 > 0。因此在 n >= 5 的情況下，將繩子剪成一段為 2 或者 3，得到的乘積會更大。又因為 3(n - 3) - 2(n - 2) = n - 5 >= 0，所以剪成一段長度為 3 比長度為 2 得到的乘積更大。

```java
public int integerBreak(int n) {
    if (n < 2)
        return 0;
    if (n == 2)
        return 1;
    if (n == 3)
        return 2;
    int timesOf3 = n / 3;
    if (n - timesOf3 * 3 == 1)
        timesOf3--;
    int timesOf2 = (n - timesOf3 * 3) / 2;
    return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));
}
```

### 動態規劃

```java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
        for (int j = 1; j < i; j++)
            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
    return dp[n];
}
```

# 15. 二進制中 1 的個數

[NowCoder](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

輸入一個整數，輸出該數二進制表示中 1 的個數。

### n&(n-1)

該位運算去除 n 的位級表示中最低的那一位。

```
n       : 10110100
n-1     : 10110011
n&(n-1) : 10110000
```

時間復雜度：O(M)，其中 M 表示 1 的個數。


```java
public int NumberOf1(int n) {
    int cnt = 0;
    while (n != 0) {
        cnt++;
        n &= (n - 1);
    }
    return cnt;
}
```


### Integer.bitCount()

```java
public int NumberOf1(int n) {
    return Integer.bitCount(n);
}
```

# 16. 數值的整數次方

[NowCoder](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

給定一個 double 類型的浮點數 base 和 int 類型的整數 exponent，求 base 的 exponent 次方。

## 解題思路

下面的討論中 x 代表 base，n 代表 exponent。

<div align="center"><img src="https://latex.codecogs.com/gif.latex?x^n=\left\{\begin{array}{rcl}(x*x)^{n/2}&&{n\%2=0}\\x*(x*x)^{n/2}&&{n\%2=1}\end{array}\right."/></div> <br>

因為 (x\*x)<sup>n/2</sup> 可以通過遞歸求解，並且每次遞歸 n 都減小一半，因此整個算法的時間復雜度為 O(logN)。

```java
public double Power(double base, int exponent) {
    if (exponent == 0)
        return 1;
    if (exponent == 1)
        return base;
    boolean isNegative = false;
    if (exponent < 0) {
        exponent = -exponent;
        isNegative = true;
    }
    double pow = Power(base * base, exponent / 2);
    if (exponent % 2 != 0)
        pow = pow * base;
    return isNegative ? 1 / pow : pow;
}
```

# 17. 打印從 1 到最大的 n 位數

## 題目描述

輸入數字 n，按順序打印出從 1 到最大的 n 位十進制數。比如輸入 3，則打印出 1、2、3 一直到最大的 3 位數即 999。

## 解題思路

由於 n 可能會非常大，因此不能直接用 int 表示數字，而是用 char 數組進行存儲。

使用回溯法得到所有的數。

```java
public void print1ToMaxOfNDigits(int n) {
    if (n <= 0)
        return;
    char[] number = new char[n];
    print1ToMaxOfNDigits(number, 0);
}

private void print1ToMaxOfNDigits(char[] number, int digit) {
    if (digit == number.length) {
        printNumber(number);
        return;
    }
    for (int i = 0; i < 10; i++) {
        number[digit] = (char) (i + '0');
        print1ToMaxOfNDigits(number, digit + 1);
    }
}

private void printNumber(char[] number) {
    int index = 0;
    while (index < number.length && number[index] == '0')
        index++;
    while (index < number.length)
        System.out.print(number[index++]);
    System.out.println();
}
```

# 18.1 在 O(1) 時間內刪除鏈表節點

## 解題思路

① 如果該節點不是尾節點，那麼可以直接將下一個節點的值賦給該節點，然後令該節點指向下下個節點，再刪除下一個節點，時間復雜度為 O(1)。

<div align="center"> <img src="pics/27ff9548-edb6-4465-92c8-7e6386e0b185.png" width="600"/> </div><br>

② 如果鏈表只有一個節點，那麼直接

② 否則，就需要先遍歷鏈表，找到節點的前一個節點，然後讓前一個節點指向 null，時間復雜度為 O(N)。

<div align="center"> <img src="pics/280f7728-594f-4811-a03a-fa8d32c013da.png" width="600"/> </div><br>

綜上，如果進行 N 次操作，那麼大約需要操作節點的次數為 N-1+N=2N-1，其中 N-1 表示 N-1 個不是尾節點的每個節點以 O(1) 的時間復雜度操作節點的總次數，N 表示 1 個尾節點以 O(N) 的時間復雜度操作節點的總次數。(2N-1)/N \~ 2，因此該算法的平均時間復雜度為 O(1)。

```java
public ListNode deleteNode(ListNode head, ListNode tobeDelete) {
    if (head == null || tobeDelete == null)
        return null;
    if (tobeDelete.next != null) {
        // 要刪除的節點不是尾節點
        ListNode next = tobeDelete.next;
        tobeDelete.val = next.val;
        tobeDelete.next = next.next;
    } else {
        if (head == tobeDelete)
             // 只有一個節點
            head = null;
        else {
            ListNode cur = head;
            while (cur.next != tobeDelete)
                cur = cur.next;
            cur.next = null;
        }
    }
    return head;
}
```

# 18.2 刪除鏈表中重復的結點

[NowCoder](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

<div align="center"> <img src="pics/8433fbb2-c35c-45ef-831d-e3ca42aebd51.png" width="500"/> </div><br>

## 解題描述

```java
public ListNode deleteDuplication(ListNode pHead) {
    if (pHead == null || pHead.next == null)
        return pHead;
    ListNode next = pHead.next;
    if (pHead.val == next.val) {
        while (next != null && pHead.val == next.val)
            next = next.next;
        return deleteDuplication(next);
    } else {
        pHead.next = deleteDuplication(pHead.next);
        return pHead;
    }
}
```

# 19. 正則表達式匹配

[NowCoder](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

請實現一個函數用來匹配包括 '.' 和 '\*' 的正則表達式。模式中的字符 '.' 表示任意一個字符，而 '\*' 表示它前面的字符可以出現任意次（包含 0 次）。

在本題中，匹配是指字符串的所有字符匹配整個模式。例如，字符串 "aaa" 與模式 "a.a" 和 "ab\*ac\*a" 匹配，但是與 "aa.a" 和 "ab\*a" 均不匹配。

## 解題思路

應該注意到，'.' 是用來當做一個任意字符，而 '\*' 是用來重復前面的字符。這兩個的作用不同，不能把 '.' 的作用和 '\*' 進行類比，從而把它當成重復前面字符一次。

```java
public boolean match(char[] str, char[] pattern) {

    int m = str.length, n = pattern.length;
    boolean[][] dp = new boolean[m + 1][n + 1];

    dp[0][0] = true;
    for (int i = 1; i <= n; i++)
        if (pattern[i - 1] == '*')
            dp[0][i] = dp[0][i - 2];

    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            if (str[i - 1] == pattern[j - 1] || pattern[j - 1] == '.')
                dp[i][j] = dp[i - 1][j - 1];
            else if (pattern[j - 1] == '*')
                if (pattern[j - 2] == str[i - 1] || pattern[j - 2] == '.') {
                    dp[i][j] |= dp[i][j - 1]; // a* counts as single a
                    dp[i][j] |= dp[i - 1][j]; // a* counts as multiple a
                    dp[i][j] |= dp[i][j - 2]; // a* counts as empty
                } else
                    dp[i][j] = dp[i][j - 2];   // a* only counts as empty

    return dp[m][n];
}
```

# 20. 表示數值的字符串

[NowCoder](https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

```html
true

"+100"
"5e2"
"-123"
"3.1416"
"-1E-16"

false

"12e"
"1a3.14"
"1.2.3"
"+-5"
"12e+4.3"
```


## 解題思路

使用正則表達式進行匹配。

```html
[]  ： 字符集合
()  ： 分組
?   ： 重復 0 ~ 1
+   ： 重復 1 ~ n
*   ： 重復 0 ~ n
.   ： 任意字符
\\. ： 轉義後的 .
\\d ： 數字
```

```java
public boolean isNumeric(char[] str) {
    if (str == null || str.length == 0)
        return false;
    return new String(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");
}
```

# 21. 調整數組順序使奇數位於偶數前面

[NowCoder](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

需要保證奇數和奇數，偶數和偶數之間的相對位置不變，這和書本不太一樣。

<div align="center"> <img src="pics/7_2001550475133282.png"/> </div><br>

## 解題思路

```java
public void reOrderArray(int[] nums) {
    // 奇數個數
    int oddCnt = 0;
    for (int val : nums)
        if (val % 2 == 1)
            oddCnt++;
    int[] copy = nums.clone();
    int i = 0, j = oddCnt;
    for (int num : copy) {
        if (num % 2 == 1)
            nums[i++] = num;
        else
            nums[j++] = num;
    }
}
```

# 22. 鏈表中倒數第 K 個結點

[NowCoder](https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解題思路

設鏈表的長度為 N。設兩個指針 P1 和 P2，先讓 P1 移動 K 個節點，則還有 N - K 個節點可以移動。此時讓 P1 和 P2 同時移動，可以知道當 P1 移動到鏈表結尾時，P2 移動到 N - K 個節點處，該位置就是倒數第 K 個節點。

<div align="center"> <img src="pics/ea2304ce-268b-4238-9486-4d8f8aea8ca4.png" width="500"/> </div><br>

```java
public ListNode FindKthToTail(ListNode head, int k) {
    if (head == null)
        return null;
    ListNode P1 = head;
    while (P1 != null && k-- > 0)
        P1 = P1.next;
    if (k > 0)
        return null;
    ListNode P2 = head;
    while (P1 != null) {
        P1 = P1.next;
        P2 = P2.next;
    }
    return P2;
}
```

# 23. 鏈表中環的入口結點

[NowCoder](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

一個鏈表中包含環，請找出該鏈表的環的入口結點。要求不能使用額外的空間。

## 解題思路

使用雙指針，一個指針 fast 每次移動兩個節點，一個指針 slow 每次移動一個節點。因為存在環，所以兩個指針必定相遇在環中的某個節點上。假設相遇點在下圖的 z1 位置，此時 fast 移動的節點數為 x+2y+z，slow 為 x+y，由於 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。

在相遇點，slow 要到環的入口點還需要移動 z 個節點，如果讓 fast 重新從頭開始移動，並且速度變為每次移動一個節點，那麼它到環入口點還需要移動 x 個節點。在上面已經推導出 x=z，因此 fast 和 slow 將在環入口點相遇。

<div align="center"> <img src="pics/d5d3b7ae-2712-412e-98f1-633ce6ec5955.png" width="500"/> </div><br>


```java
public ListNode EntryNodeOfLoop(ListNode pHead) {
    if (pHead == null || pHead.next == null)
        return null;
    ListNode slow = pHead, fast = pHead;
    do {
        fast = fast.next.next;
        slow = slow.next;
    } while (slow != fast);
    fast = pHead;
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}
```

# 24. 反轉鏈表

[NowCoder](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解題思路

### 遞歸

```java
public ListNode ReverseList(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode next = head.next;
    head.next = null;
    ListNode newHead = ReverseList(next);
    next.next = head;
    return newHead;
}
```

### 迭代

```java
public ListNode ReverseList(ListNode head) {
    ListNode newList = new ListNode(-1);
    while (head != null) {
        ListNode next = head.next;
        head.next = newList.next;
        newList.next = head;
        head = next;
    }
    return newList.next;
}
```

# 25. 合並兩個排序的鏈表

[NowCoder](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

<div align="center"> <img src="pics/43f2cafa-3568-4a89-a895-4725666b94a6.png" width="500"/> </div><br>

## 解題思路

### 遞歸

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    if (list1 == null)
        return list2;
    if (list2 == null)
        return list1;
    if (list1.val <= list2.val) {
        list1.next = Merge(list1.next, list2);
        return list1;
    } else {
        list2.next = Merge(list1, list2.next);
        return list2;
    }
}
```

### 迭代

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    ListNode head = new ListNode(-1);
    ListNode cur = head;
    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    if (list1 != null)
        cur.next = list1;
    if (list2 != null)
        cur.next = list2;
    return head.next;
}
```

# 26. 樹的子結構

[NowCoder](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

<div align="center"> <img src="pics/4583e24f-424b-4d50-8a14-2c38a1827d4a.png" width="500"/> </div><br>

## 解題思路

```java
public boolean HasSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null || root2 == null)
        return false;
    return isSubtreeWithRoot(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
}

private boolean isSubtreeWithRoot(TreeNode root1, TreeNode root2) {
    if (root2 == null)
        return true;
    if (root1 == null)
        return false;
    if (root1.val != root2.val)
        return false;
    return isSubtreeWithRoot(root1.left, root2.left) && isSubtreeWithRoot(root1.right, root2.right);
}
```

# 27. 二叉樹的鏡像

[NowCoder](https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

<div align="center"> <img src="pics/a2d13178-f1ef-4811-a240-1fe95b55b1eb.png" width="300"/> </div><br>

## 解題思路

```java
public void Mirror(TreeNode root) {
    if (root == null)
        return;
    swap(root);
    Mirror(root.left);
    Mirror(root.right);
}

private void swap(TreeNode root) {
    TreeNode t = root.left;
    root.left = root.right;
    root.right = t;
}
```

# 28 對稱的二叉樹

[NowCder](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

<div align="center"> <img src="pics/f42443e0-208d-41ea-be44-c7fd97d2e3bf.png" width="300"/> </div><br>

## 解題思路

```java
boolean isSymmetrical(TreeNode pRoot) {
    if (pRoot == null)
        return true;
    return isSymmetrical(pRoot.left, pRoot.right);
}

boolean isSymmetrical(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null)
        return true;
    if (t1 == null || t2 == null)
        return false;
    if (t1.val != t2.val)
        return false;
    return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);
}
```

# 29. 順時針打印矩陣

[NowCoder](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

下圖的矩陣順時針打印結果為：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10

<div align="center"> <img src="pics/8_2001550475451664.png"/> </div><br>

## 解題思路

```java
public ArrayList<Integer> printMatrix(int[][] matrix) {
    ArrayList<Integer> ret = new ArrayList<>();
    int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1;
    while (r1 <= r2 && c1 <= c2) {
        for (int i = c1; i <= c2; i++)
            ret.add(matrix[r1][i]);
        for (int i = r1 + 1; i <= r2; i++)
            ret.add(matrix[i][c2]);
        if (r1 != r2)
            for (int i = c2 - 1; i >= c1; i--)
                ret.add(matrix[r2][i]);
        if (c1 != c2)
            for (int i = r2 - 1; i > r1; i--)
                ret.add(matrix[i][c1]);
        r1++; r2--; c1++; c2--;
    }
    return ret;
}
```

# 30. 包含 min 函數的棧

[NowCoder](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

定義棧的數據結構，請在該類型中實現一個能夠得到棧最小元素的 min 函數。

## 解題思路

```java
private Stack<Integer> dataStack = new Stack<>();
private Stack<Integer> minStack = new Stack<>();

public void push(int node) {
    dataStack.push(node);
    minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));
}

public void pop() {
    dataStack.pop();
    minStack.pop();
}

public int top() {
    return dataStack.peek();
}

public int min() {
    return minStack.peek();
}
```

# 31. 棧的壓入、彈出序列

[NowCoder](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

輸入兩個整數序列，第一個序列表示棧的壓入順序，請判斷第二個序列是否為該棧的彈出順序。假設壓入棧的所有數字均不相等。

例如序列 1,2,3,4,5 是某棧的壓入順序，序列 4,5,3,2,1 是該壓棧序列對應的一個彈出序列，但 4,3,5,1,2 就不可能是該壓棧序列的彈出序列。

## 解題思路

使用一個棧來模擬壓入彈出操作。

```java
public boolean IsPopOrder(int[] pushSequence, int[] popSequence) {
    int n = pushSequence.length;
    Stack<Integer> stack = new Stack<>();
    for (int pushIndex = 0, popIndex = 0; pushIndex < n; pushIndex++) {
        stack.push(pushSequence[pushIndex]);
        while (popIndex < n && !stack.isEmpty() 
                && stack.peek() == popSequence[popIndex]) {
            stack.pop();
            popIndex++;
        }
    }
    return stack.isEmpty();
}
```

# 32.1 從上往下打印二叉樹

[NowCoder](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

從上往下打印出二叉樹的每個節點，同層節點從左至右打印。

例如，以下二叉樹層次遍歷的結果為：1,2,3,4,5,6,7

<div align="center"> <img src="pics/348bc2db-582e-4aca-9f88-38c40e9a0e69.png" width="250"/> </div><br>

## 解題思路

使用隊列來進行層次遍歷。

不需要使用兩個隊列分別存儲當前層的節點和下一層的節點，因為在開始遍歷一層的節點時，當前隊列中的節點數就是當前層的節點數，只要控制遍歷這麼多節點數，就能保證這次遍歷的都是當前層的節點。

```java
public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    ArrayList<Integer> ret = new ArrayList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        while (cnt-- > 0) {
            TreeNode t = queue.poll();
            if (t == null)
                continue;
            ret.add(t.val);
            queue.add(t.left);
            queue.add(t.right);
        }
    }
    return ret;
}
```

# 32.2 把二叉樹打印成多行

[NowCoder](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

和上題幾乎一樣。

## 解題思路

```java
ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(pRoot);
    while (!queue.isEmpty()) {
        ArrayList<Integer> list = new ArrayList<>();
        int cnt = queue.size();
        while (cnt-- > 0) {
            TreeNode node = queue.poll();
            if (node == null)
                continue;
            list.add(node.val);
            queue.add(node.left);
            queue.add(node.right);
        }
        if (list.size() != 0)
            ret.add(list);
    }
    return ret;
}
```

# 32.3 按之字形順序打印二叉樹

[NowCoder](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

請實現一個函數按照之字形打印二叉樹，即第一行按照從左到右的順序打印，第二層按照從右至左的順序打印，第三行按照從左到右的順序打印，其他行以此類推。

## 解題思路

```java
public ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(pRoot);
    boolean reverse = false;
    while (!queue.isEmpty()) {
        ArrayList<Integer> list = new ArrayList<>();
        int cnt = queue.size();
        while (cnt-- > 0) {
            TreeNode node = queue.poll();
            if (node == null)
                continue;
            list.add(node.val);
            queue.add(node.left);
            queue.add(node.right);
        }
        if (reverse)
            Collections.reverse(list);
        reverse = !reverse;
        if (list.size() != 0)
            ret.add(list);
    }
    return ret;
}
```

# 33. 二叉搜索樹的後序遍歷序列

[NowCoder](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

輸入一個整數數組，判斷該數組是不是某二叉搜索樹的後序遍歷的結果。假設輸入的數組的任意兩個數字都互不相同。

例如，下圖是後序遍歷序列 1,3,2 所對應的二叉搜索樹。

<div align="center"> <img src="pics/836a4eaf-4798-4e48-b52a-a3dab9435ace.png" width="150"/> </div><br>

## 解題思路

```java
public boolean VerifySquenceOfBST(int[] sequence) {
    if (sequence == null || sequence.length == 0)
        return false;
    return verify(sequence, 0, sequence.length - 1);
}

private boolean verify(int[] sequence, int first, int last) {
    if (last - first <= 1)
        return true;
    int rootVal = sequence[last];
    int cutIndex = first;
    while (cutIndex < last && sequence[cutIndex] <= rootVal)
        cutIndex++;
    for (int i = cutIndex; i < last; i++)
        if (sequence[i] < rootVal)
            return false;
    return verify(sequence, first, cutIndex - 1) && verify(sequence, cutIndex, last - 1);
}
```

# 34. 二叉樹中和為某一值的路徑

[NowCoder](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

輸入一顆二叉樹和一個整數，打印出二叉樹中結點值的和為輸入整數的所有路徑。路徑定義為從樹的根結點開始往下一直到葉結點所經過的結點形成一條路徑。

下圖的二叉樹有兩條和為 22 的路徑：10, 5, 7 和 10, 12

<div align="center"> <img src="pics/f5477abd-c246-4851-89ab-6b1cde2549b1.png" width="200"/> </div><br>

## 解題思路

```java
private ArrayList<ArrayList<Integer>> ret = new ArrayList<>();

public ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {
    backtracking(root, target, new ArrayList<>());
    return ret;
}

private void backtracking(TreeNode node, int target, ArrayList<Integer> path) {
    if (node == null)
        return;
    path.add(node.val);
    target -= node.val;
    if (target == 0 && node.left == null && node.right == null) {
        ret.add(new ArrayList<>(path));
    } else {
        backtracking(node.left, target, path);
        backtracking(node.right, target, path);
    }
    path.remove(path.size() - 1);
}
```

# 35. 復雜鏈表的復制

[NowCoder](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

輸入一個復雜鏈表（每個節點中有節點值，以及兩個指針，一個指向下一個節點，另一個特殊指針指向任意一個節點），返回結果為復制後復雜鏈表的 head。

```java
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
```

<div align="center"> <img src="pics/a01d1516-8168-461a-a24b-620b9cfc40f4.png" width="300"/> </div><br>

## 解題思路

第一步，在每個節點的後面插入復制的節點。

<div align="center"> <img src="pics/2e6c72f5-3b8e-4e32-b87b-9491322628fe.png" width="600"/> </div><br>

第二步，對復制節點的 random 鏈接進行賦值。

<div align="center"> <img src="pics/323ffd6c-8b54-4f3e-b361-555a6c8bf218.png" width="600"/> </div><br>

第三步，拆分。

<div align="center"> <img src="pics/8f3b9519-d705-48fe-87ad-2e4052fc81d2.png" width="600"/> </div><br>

```java
public RandomListNode Clone(RandomListNode pHead) {
    if (pHead == null)
        return null;
    // 插入新節點
    RandomListNode cur = pHead;
    while (cur != null) {
        RandomListNode clone = new RandomListNode(cur.label);
        clone.next = cur.next;
        cur.next = clone;
        cur = clone.next;
    }
    // 建立 random 鏈接
    cur = pHead;
    while (cur != null) {
        RandomListNode clone = cur.next;
        if (cur.random != null)
            clone.random = cur.random.next;
        cur = clone.next;
    }
    // 拆分
    cur = pHead;
    RandomListNode pCloneHead = pHead.next;
    while (cur.next != null) {
        RandomListNode next = cur.next;
        cur.next = next.next;
        cur = next;
    }
    return pCloneHead;
}
```

# 36. 二叉搜索樹與雙向鏈表

[NowCoder](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

輸入一棵二叉搜索樹，將該二叉搜索樹轉換成一個排序的雙向鏈表。要求不能創建任何新的結點，只能調整樹中結點指針的指向。

<div align="center"> <img src="pics/79b12431-6d9d-4a7d-985b-1b79bc5bf5fb.png" width="400"/> </div><br>

## 解題思路

```java
private TreeNode pre = null;
private TreeNode head = null;

public TreeNode Convert(TreeNode root) {
    inOrder(root);
    return head;
}

private void inOrder(TreeNode node) {
    if (node == null)
        return;
    inOrder(node.left);
    node.left = pre;
    if (pre != null)
        pre.right = node;
    pre = node;
    if (head == null)
        head = node;
    inOrder(node.right);
}
```

# 37. 序列化二叉樹

[NowCoder](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

請實現兩個函數，分別用來序列化和反序列化二叉樹。

## 解題思路

```java
private String deserializeStr;

public String Serialize(TreeNode root) {
    if (root == null)
        return "#";
    return root.val + " " + Serialize(root.left) + " " + Serialize(root.right);
}

public TreeNode Deserialize(String str) {
    deserializeStr = str;
    return Deserialize();
}

private TreeNode Deserialize() {
    if (deserializeStr.length() == 0)
        return null;
    int index = deserializeStr.indexOf(" ");
    String node = index == -1 ? deserializeStr : deserializeStr.substring(0, index);
    deserializeStr = index == -1 ? "" : deserializeStr.substring(index + 1);
    if (node.equals("#"))
        return null;
    int val = Integer.valueOf(node);
    TreeNode t = new TreeNode(val);
    t.left = Deserialize();
    t.right = Deserialize();
    return t;
}
```

# 38. 字符串的排列

[NowCoder](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

輸入一個字符串，按字典序打印出該字符串中字符的所有排列。例如輸入字符串 abc，則打印出由字符 a, b, c 所能排列出來的所有字符串 abc, acb, bac, bca, cab 和 cba。

## 解題思路

```java
private ArrayList<String> ret = new ArrayList<>();

public ArrayList<String> Permutation(String str) {
    if (str.length() == 0)
        return ret;
    char[] chars = str.toCharArray();
    Arrays.sort(chars);
    backtracking(chars, new boolean[chars.length], new StringBuilder());
    return ret;
}

private void backtracking(char[] chars, boolean[] hasUsed, StringBuilder s) {
    if (s.length() == chars.length) {
        ret.add(s.toString());
        return;
    }
    for (int i = 0; i < chars.length; i++) {
        if (hasUsed[i])
            continue;
        if (i != 0 && chars[i] == chars[i - 1] && !hasUsed[i - 1]) /* 保證不重復 */
            continue;
        hasUsed[i] = true;
        s.append(chars[i]);
        backtracking(chars, hasUsed, s);
        s.deleteCharAt(s.length() - 1);
        hasUsed[i] = false;
    }
}
```

# 39. 數組中出現次數超過一半的數字

[NowCoder](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tqId=11181&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解題思路

多數投票問題，可以利用 Boyer-Moore Majority Vote Algorithm 來解決這個問題，使得時間復雜度為 O(N)。

使用 cnt 來統計一個元素出現的次數，當遍歷到的元素和統計元素相等時，令 cnt++，否則令 cnt--。如果前面查找了 i 個元素，且 cnt == 0，說明前 i 個元素沒有 majority，或者有 majority，但是出現的次數少於 i / 2 ，因為如果多於 i / 2 的話 cnt 就一定不會為 0 。此時剩下的 n - i 個元素中，majority 的數目依然多於 (n - i) / 2，因此繼續查找就能找出 majority。

```java
public int MoreThanHalfNum_Solution(int[] nums) {
    int majority = nums[0];
    for (int i = 1, cnt = 1; i < nums.length; i++) {
        cnt = nums[i] == majority ? cnt + 1 : cnt - 1;
        if (cnt == 0) {
            majority = nums[i];
            cnt = 1;
        }
    }
    int cnt = 0;
    for (int val : nums)
        if (val == majority)
            cnt++;
    return cnt > nums.length / 2 ? majority : 0;
}
```

# 40. 最小的 K 個數

[NowCoder](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解題思路

### 快速選擇

- 復雜度：O(N) + O(1)
- 只有當允許修改數組元素時才可以使用

快速排序的 partition() 方法，會返回一個整數 j 使得 a[l..j-1] 小於等於 a[j]，且 a[j+1..h] 大於等於 a[j]，此時 a[j] 就是數組的第 j 大元素。可以利用這個特性找出數組的第 K 個元素，這種找第 K 個元素的算法稱為快速選擇算法。

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {
    ArrayList<Integer> ret = new ArrayList<>();
    if (k > nums.length || k <= 0)
        return ret;
    findKthSmallest(nums, k - 1);
    /* findKthSmallest 會改變數組，使得前 k 個數都是最小的 k 個數 */
    for (int i = 0; i < k; i++)
        ret.add(nums[i]);
    return ret;
}

public void findKthSmallest(int[] nums, int k) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int j = partition(nums, l, h);
        if (j == k)
            break;
        if (j > k)
            h = j - 1;
        else
            l = j + 1;
    }
}

private int partition(int[] nums, int l, int h) {
    int p = nums[l];     /* 切分元素 */
    int i = l, j = h + 1;
    while (true) {
        while (i != h && nums[++i] < p) ;
        while (j != l && nums[--j] > p) ;
        if (i >= j)
            break;
        swap(nums, i, j);
    }
    swap(nums, l, j);
    return j;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

### 大小為 K 的最小堆

- 復雜度：O(NlogK) + O(K)
- 特別適合處理海量數據

應該使用大頂堆來維護最小堆，而不能直接創建一個小頂堆並設置一個大小，企圖讓小頂堆中的元素都是最小元素。

維護一個大小為 K 的最小堆過程如下：在添加一個元素之後，如果大頂堆的大小大於 K，那麼需要將大頂堆的堆頂元素去除。

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {
    if (k > nums.length || k <= 0)
        return new ArrayList<>();
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);
    for (int num : nums) {
        maxHeap.add(num);
        if (maxHeap.size() > k)
            maxHeap.poll();
    }
    return new ArrayList<>(maxHeap);
}
```

# 41.1 數據流中的中位數

[NowCoder](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

如何得到一個數據流中的中位數？如果從數據流中讀出奇數個數值，那麼中位數就是所有數值排序之後位於中間的數值。如果從數據流中讀出偶數個數值，那麼中位數就是所有數值排序之後中間兩個數的平均值。

## 解題思路

```java
/* 大頂堆，存儲左半邊元素 */
private PriorityQueue<Integer> left = new PriorityQueue<>((o1, o2) -> o2 - o1);
/* 小頂堆，存儲右半邊元素，並且右半邊元素都大於左半邊 */
private PriorityQueue<Integer> right = new PriorityQueue<>();
/* 當前數據流讀入的元素個數 */
private int N = 0;

public void Insert(Integer val) {
    /* 插入要保證兩個堆存於平衡狀態 */
    if (N % 2 == 0) {
        /* N 為偶數的情況下插入到右半邊。
         * 因為右半邊元素都要大於左半邊，但是新插入的元素不一定比左半邊元素來的大，
         * 因此需要先將元素插入左半邊，然後利用左半邊為大頂堆的特點，取出堆頂元素即為最大元素，此時插入右半邊 */
        left.add(val);
        right.add(left.poll());
    } else {
        right.add(val);
        left.add(right.poll());
    }
    N++;
}

public Double GetMedian() {
    if (N % 2 == 0)
        return (left.peek() + right.peek()) / 2.0;
    else
        return (double) right.peek();
}
```

# 41.2 字符流中第一個不重復的字符

[NowCoder](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

請實現一個函數用來找出字符流中第一個只出現一次的字符。例如，當從字符流中只讀出前兩個字符 "go" 時，第一個只出現一次的字符是 "g"。當從該字符流中讀出前六個字符“google" 時，第一個只出現一次的字符是 "l"。

## 解題思路

```java
private int[] cnts = new int[256];
private Queue<Character> queue = new LinkedList<>();

public void Insert(char ch) {
    cnts[ch]++;
    queue.add(ch);
    while (!queue.isEmpty() && cnts[queue.peek()] > 1)
        queue.poll();
}

public char FirstAppearingOnce() {
    return queue.isEmpty() ? '#' : queue.peek();
}
```

# 42. 連續子數組的最大和

[NowCoder](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

{6, -3, -2, 7, -15, 1, 2, 2}，連續子數組的最大和為 8（從第 0 個開始，到第 3 個為止）。

## 解題思路

```java
public int FindGreatestSumOfSubArray(int[] nums) {
    if (nums == null || nums.length == 0)
        return 0;
    int greatestSum = Integer.MIN_VALUE;
    int sum = 0;
    for (int val : nums) {
        sum = sum <= 0 ? val : sum + val;
        greatestSum = Math.max(greatestSum, sum);
    }
    return greatestSum;
}
```

# 43. 從 1 到 n 整數中 1 出現的次數

[NowCoder](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解題思路

```java
public int NumberOf1Between1AndN_Solution(int n) {
    int cnt = 0;
    for (int m = 1; m <= n; m *= 10) {
        int a = n / m, b = n % m;
        cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
    }
    return cnt;
}
```

> [Leetcode : 233. Number of Digit One](https://leetcode.com/problems/number-of-digit-one/discuss/64381/4+-lines-O(log-n)-C++JavaPython)

# 44. 數字序列中的某一位數字

## 題目描述

數字以 0123456789101112131415... 的格式序列化到一個字符串中，求這個字符串的第 index 位。

## 解題思路

```java
public int getDigitAtIndex(int index) {
    if (index < 0)
        return -1;
    int place = 1;  // 1 表示個位，2 表示 十位...
    while (true) {
        int amount = getAmountOfPlace(place);
        int totalAmount = amount * place;
        if (index < totalAmount)
            return getDigitAtIndex(index, place);
        index -= totalAmount;
        place++;
    }
}

/**
 * place 位數的數字組成的字符串長度
 * 10, 90, 900, ...
 */
private int getAmountOfPlace(int place) {
    if (place == 1)
        return 10;
    return (int) Math.pow(10, place - 1) * 9;
}

/**
 * place 位數的起始數字
 * 0, 10, 100, ...
 */
private int getBeginNumberOfPlace(int place) {
    if (place == 1)
        return 0;
    return (int) Math.pow(10, place - 1);
}

/**
 * 在 place 位數組成的字符串中，第 index 個數
 */
private int getDigitAtIndex(int index, int place) {
    int beginNumber = getBeginNumberOfPlace(place);
    int shiftNumber = index / place;
    String number = (beginNumber + shiftNumber) + "";
    int count = index % place;
    return number.charAt(count) - '0';
}
```

# 45. 把數組排成最小的數

[NowCoder](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

輸入一個正整數數組，把數組裡所有數字拼接起來排成一個數，打印能拼接出的所有數字中最小的一個。例如輸入數組 {3，32，321}，則打印出這三個數字能排成的最小數字為 321323。

## 解題思路

可以看成是一個排序問題，在比較兩個字符串 S1 和 S2 的大小時，應該比較的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 < S2+S1，那麼應該把 S1 排在前面，否則應該把 S2 排在前面。

```java
public String PrintMinNumber(int[] numbers) {
    if (numbers == null || numbers.length == 0)
        return "";
    int n = numbers.length;
    String[] nums = new String[n];
    for (int i = 0; i < n; i++)
        nums[i] = numbers[i] + "";
    Arrays.sort(nums, (s1, s2) -> (s1 + s2).compareTo(s2 + s1));
    String ret = "";
    for (String str : nums)
        ret += str;
    return ret;
}
```

# 46. 把數字翻譯成字符串

[Leetcode](https://leetcode.com/problems/decode-ways/description/)

## 題目描述

給定一個數字，按照如下規則翻譯成字符串：1 翻譯成“a”，2 翻譯成“b”... 26 翻譯成“z”。一個數字有多種翻譯可能，例如 12258 一共有 5 種，分別是 abbeh，lbeh，aveh，abyh，lyh。實現一個函數，用來計算一個數字有多少種不同的翻譯方法。

## 解題思路

```java
public int numDecodings(String s) {
    if (s == null || s.length() == 0)
        return 0;
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == '0' ? 0 : 1;
    for (int i = 2; i <= n; i++) {
        int one = Integer.valueOf(s.substring(i - 1, i));
        if (one != 0)
            dp[i] += dp[i - 1];
        if (s.charAt(i - 2) == '0')
            continue;
        int two = Integer.valueOf(s.substring(i - 2, i));
        if (two <= 26)
            dp[i] += dp[i - 2];
    }
    return dp[n];
}
```

# 47. 禮物的最大價值

[NowCoder](https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab)

## 題目描述

在一個 m\*n 的棋盤的每一個格都放有一個禮物，每個禮物都有一定價值（大於 0）。從左上角開始拿禮物，每次向右或向下移動一格，直到右下角結束。給定一個棋盤，求拿到禮物的最大價值。例如，對於如下棋盤

```
1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5
```

禮物的最大價值為 1+12+5+7+7+16+5=53。

## 解題思路

應該用動態規劃求解，而不是深度優先搜索，深度優先搜索過於復雜，不是最優解。

```java
public int getMost(int[][] values) {
    if (values == null || values.length == 0 || values[0].length == 0)
        return 0;
    int n = values[0].length;
    int[] dp = new int[n];
    for (int[] value : values) {
        dp[0] += value[0];
        for (int i = 1; i < n; i++)
            dp[i] = Math.max(dp[i], dp[i - 1]) + value[i];
    }
    return dp[n - 1];
}
```

# 48. 最長不含重復字符的子字符串

## 題目描述

輸入一個字符串（只包含 a\~z 的字符），求其最長不含重復字符的子字符串的長度。例如對於 arabcacfr，最長不含重復字符的子字符串為 acfr，長度為 4。

## 解題思路

```java
public int longestSubStringWithoutDuplication(String str) {
    int curLen = 0;
    int maxLen = 0;
    int[] preIndexs = new int[26];
    Arrays.fill(preIndexs, -1);
    for (int curI = 0; curI < str.length(); curI++) {
        int c = str.charAt(curI) - 'a';
        int preI = preIndexs[c];
        if (preI == -1 || curI - preI > curLen) {
            curLen++;
        } else {
            maxLen = Math.max(maxLen, curLen);
            curLen = curI - preI;
        }
        preIndexs[c] = curI;
    }
    maxLen = Math.max(maxLen, curLen);
    return maxLen;
}
```

# 49. 醜數

[NowCoder](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

把只包含因子 2、3 和 5 的數稱作醜數（Ugly Number）。例如 6、8 都是醜數，但 14 不是，因為它包含因子 7。習慣上我們把 1 當做是第一個醜數。求按從小到大的順序的第 N 個醜數。

## 解題思路

```java
public int GetUglyNumber_Solution(int N) {
    if (N <= 6)
        return N;
    int i2 = 0, i3 = 0, i5 = 0;
    int[] dp = new int[N];
    dp[0] = 1;
    for (int i = 1; i < N; i++) {
        int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5;
        dp[i] = Math.min(next2, Math.min(next3, next5));
        if (dp[i] == next2)
            i2++;
        if (dp[i] == next3)
            i3++;
        if (dp[i] == next5)
            i5++;
    }
    return dp[N - 1];
}
```

# 50. 第一個只出現一次的字符位置

[NowCoder](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

在一個字符串中找到第一個只出現一次的字符，並返回它的位置。

## 解題思路

最直觀的解法是使用 HashMap 對出現次數進行統計，但是考慮到要統計的字符範圍有限，因此可以使用整型數組代替 HashMap。

```java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[256];
    for (int i = 0; i < str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
}
```

以上實現的空間復雜度還不是最優的。考慮到只需要找到只出現一次的字符，那麼需要統計的次數信息只有 0,1,更大，使用兩個比特位就能存儲這些信息。

```java
public int FirstNotRepeatingChar2(String str) {
    BitSet bs1 = new BitSet(256);
    BitSet bs2 = new BitSet(256);
    for (char c : str.toCharArray()) {
        if (!bs1.get(c) && !bs2.get(c))
            bs1.set(c);     // 0 0 -> 0 1
        else if (bs1.get(c) && !bs2.get(c))
            bs2.set(c);     // 0 1 -> 1 1
    }
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (bs1.get(c) && !bs2.get(c))  // 0 1
            return i;
    }
    return -1;
}
```

# 51. 數組中的逆序對

[NowCoder](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

在數組中的兩個數字，如果前面一個數字大於後面的數字，則這兩個數字組成一個逆序對。輸入一個數組，求出這個數組中的逆序對的總數。

## 解題思路

```java
private long cnt = 0;
private int[] tmp;  // 在這裡聲明輔助數組，而不是在 merge() 遞歸函數中聲明

public int InversePairs(int[] nums) {
    tmp = new int[nums.length];
    mergeSort(nums, 0, nums.length - 1);
    return (int) (cnt % 1000000007);
}

private void mergeSort(int[] nums, int l, int h) {
    if (h - l < 1)
        return;
    int m = l + (h - l) / 2;
    mergeSort(nums, l, m);
    mergeSort(nums, m + 1, h);
    merge(nums, l, m, h);
}

private void merge(int[] nums, int l, int m, int h) {
    int i = l, j = m + 1, k = l;
    while (i <= m || j <= h) {
        if (i > m)
            tmp[k] = nums[j++];
        else if (j > h)
            tmp[k] = nums[i++];
        else if (nums[i] < nums[j])
            tmp[k] = nums[i++];
        else {
            tmp[k] = nums[j++];
            this.cnt += m - i + 1;  // nums[i] >= nums[j]，說明 nums[i...mid] 都大於 nums[j]
        }
        k++;
    }
    for (k = l; k <= h; k++)
        nums[k] = tmp[k];
}
```

# 52. 兩個鏈表的第一個公共結點

[NowCoder](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

<div align="center"> <img src="pics/8f6f9dc9-9ecd-47c8-b50e-2814f0219056.png" width="500"/> </div><br>

## 解題思路

設 A 的長度為 a + c，B 的長度為 b + c，其中 c 為尾部公共部分長度，可知 a + c + b = b + c + a。

當訪問鏈表 A 的指針訪問到鏈表尾部時，令它從鏈表 B 的頭部重新開始訪問鏈表 B；同樣地，當訪問鏈表 B 的指針訪問到鏈表尾部時，令它從鏈表 A 的頭部重新開始訪問鏈表 A。這樣就能控制訪問 A 和 B 兩個鏈表的指針能同時訪問到交點。

```java
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    ListNode l1 = pHead1, l2 = pHead2;
    while (l1 != l2) {
        l1 = (l1 == null) ? pHead2 : l1.next;
        l2 = (l2 == null) ? pHead1 : l2.next;
    }
    return l1;
}
```

# 53. 數字在排序數組中出現的次數

[NowCoder](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

```html
Input:
nums = 1, 2, 3, 3, 3, 3, 4, 6
K = 3

Output:
4
```

## 解題思路

```java
public int GetNumberOfK(int[] nums, int K) {
    int first = binarySearch(nums, K);
    int last = binarySearch(nums, K + 1);
    return (first == nums.length || nums[first] != K) ? 0 : last - first;
}

private int binarySearch(int[] nums, int K) {
    int l = 0, h = nums.length;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= K)
            h = m;
        else
            l = m + 1;
    }
    return l;
}
```

# 54. 二叉查找樹的第 K 個結點

[NowCoder](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解題思路

利用二叉查找樹中序遍歷有序的特點。

```java
private TreeNode ret;
private int cnt = 0;

public TreeNode KthNode(TreeNode pRoot, int k) {
    inOrder(pRoot, k);
    return ret;
}

private void inOrder(TreeNode root, int k) {
    if (root == null || cnt >= k)
        return;
    inOrder(root.left, k);
    cnt++;
    if (cnt == k)
        ret = root;
    inOrder(root.right, k);
}
```

# 55.1 二叉樹的深度

[NowCoder](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

從根結點到葉結點依次經過的結點（含根、葉結點）形成樹的一條路徑，最長路徑的長度為樹的深度。

<div align="center"> <img src="pics/b29f8971-9cb8-480d-b986-0e60c2ece069.png" width="350"/> </div><br>

## 解題思路

```java
public int TreeDepth(TreeNode root) {
    return root == null ? 0 : 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
}
```

# 55.2 平衡二叉樹

[NowCoder](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

平衡二叉樹左右子樹高度差不超過 1。

<div align="center"> <img src="pics/e026c24d-00fa-4e7c-97a8-95a98cdc383a.png" width="300"/> </div><br>

## 解題思路

```java
private boolean isBalanced = true;

public boolean IsBalanced_Solution(TreeNode root) {
    height(root);
    return isBalanced;
}

private int height(TreeNode root) {
    if (root == null || !isBalanced)
        return 0;
    int left = height(root.left);
    int right = height(root.right);
    if (Math.abs(left - right) > 1)
        isBalanced = false;
    return 1 + Math.max(left, right);
}
```

# 56. 數組中只出現一次的數字

[NowCoder](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

一個整型數組裡除了兩個數字之外，其他的數字都出現了兩次，找出這兩個數。

## 解題思路

兩個不相等的元素在位級表示上必定會有一位存在不同，將數組的所有元素異或得到的結果為不存在重復的兩個元素異或的結果。

diff &= -diff 得到出 diff 最右側不為 0 的位，也就是不存在重復的兩個元素在位級表示上最右側不同的那一位，利用這一位就可以將兩個元素區分開來。

```java
public void FindNumsAppearOnce(int[] nums, int num1[], int num2[]) {
    int diff = 0;
    for (int num : nums)
        diff ^= num;
    diff &= -diff;
    for (int num : nums) {
        if ((num & diff) == 0)
            num1[0] ^= num;
        else
            num2[0] ^= num;
    }
}
```

# 57.1 和為 S 的兩個數字

[NowCoder](https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

輸入一個遞增排序的數組和一個數字 S，在數組中查找兩個數，使得他們的和正好是 S。如果有多對數字的和等於 S，輸出兩個數的乘積最小的。

## 解題思路

使用雙指針，一個指針指向元素較小的值，一個指針指向元素較大的值。指向較小元素的指針從頭向尾遍歷，指向較大元素的指針從尾向頭遍歷。

- 如果兩個指針指向元素的和 sum == target，那麼得到要求的結果；
- 如果 sum > target，移動較大的元素，使 sum 變小一些；
- 如果 sum < target，移動較小的元素，使 sum 變大一些。

```java
public ArrayList<Integer> FindNumbersWithSum(int[] array, int sum) {
    int i = 0, j = array.length - 1;
    while (i < j) {
        int cur = array[i] + array[j];
        if (cur == sum)
            return new ArrayList<>(Arrays.asList(array[i], array[j]));
        if (cur < sum)
            i++;
        else
            j--;
    }
    return new ArrayList<>();
}
```

# 57.2 和為 S 的連續正數序列

[NowCoder](https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

輸出所有和為 S 的連續正數序列。

例如和為 100 的連續序列有：

```
[9, 10, 11, 12, 13, 14, 15, 16]
[18, 19, 20, 21, 22]。
```

## 解題思路

```java
public ArrayList<ArrayList<Integer>> FindContinuousSequence(int sum) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    int start = 1, end = 2;
    int curSum = 3;
    while (end < sum) {
        if (curSum > sum) {
            curSum -= start;
            start++;
        } else if (curSum < sum) {
            end++;
            curSum += end;
        } else {
            ArrayList<Integer> list = new ArrayList<>();
            for (int i = start; i <= end; i++)
                list.add(i);
            ret.add(list);
            curSum -= start;
            start++;
            end++;
            curSum += end;
        }
    }
    return ret;
}
```

# 58.1 翻轉單詞順序列

[NowCoder](https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

```html
Input:
"I am a student."

Output:
"student. a am I"
```

## 解題思路

題目應該有一個隱含條件，就是不能用額外的空間。雖然 Java 的題目輸入參數為 String 類型，需要先創建一個字符數組使得空間復雜度為 O(N)，但是正確的參數類型應該和原書一樣，為字符數組，並且只能使用該字符數組的空間。任何使用了額外空間的解法在面試時都會大打折扣，包括遞歸解法。

正確的解法應該是和書上一樣，先旋轉每個單詞，再旋轉整個字符串。

```java
public String ReverseSentence(String str) {
    int n = str.length();
    char[] chars = str.toCharArray();
    int i = 0, j = 0;
    while (j <= n) {
        if (j == n || chars[j] == ' ') {
            reverse(chars, i, j - 1);
            i = j + 1;
        }
        j++;
    }
    reverse(chars, 0, n - 1);
    return new String(chars);
}

private void reverse(char[] c, int i, int j) {
    while (i < j)
        swap(c, i++, j--);
}

private void swap(char[] c, int i, int j) {
    char t = c[i];
    c[i] = c[j];
    c[j] = t;
}
```

# 58.2 左旋轉字符串

[NowCoder](https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

```html
Input:
S="abcXYZdef"
K=3

Output:
"XYZdefabc"
```

## 解題思路

先將 "abc" 和 "XYZdef" 分別翻轉，得到 "cbafedZYX"，然後再把整個字符串翻轉得到 "XYZdefabc"。

```java
public String LeftRotateString(String str, int n) {
    if (n >= str.length())
        return str;
    char[] chars = str.toCharArray();
    reverse(chars, 0, n - 1);
    reverse(chars, n, chars.length - 1);
    reverse(chars, 0, chars.length - 1);
    return new String(chars);
}

private void reverse(char[] chars, int i, int j) {
    while (i < j)
        swap(chars, i++, j--);
}

private void swap(char[] chars, int i, int j) {
    char t = chars[i];
    chars[i] = chars[j];
    chars[j] = t;
}
```

# 59. 滑動窗口的最大值

[NowCoder](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

給定一個數組和滑動窗口的大小，找出所有滑動窗口裡數值的最大值。

例如，如果輸入數組 {2, 3, 4, 2, 6, 2, 5, 1} 及滑動窗口的大小 3，那麼一共存在 6 個滑動窗口，他們的最大值分別為 {4, 4, 6, 6, 6, 5}。

## 解題思路

```java
public ArrayList<Integer> maxInWindows(int[] num, int size) {
    ArrayList<Integer> ret = new ArrayList<>();
    if (size > num.length || size < 1)
        return ret;
    PriorityQueue<Integer> heap = new PriorityQueue<>((o1, o2) -> o2 - o1);  /* 大頂堆 */
    for (int i = 0; i < size; i++)
        heap.add(num[i]);
    ret.add(heap.peek());
    for (int i = 0, j = i + size; j < num.length; i++, j++) {            /* 維護一個大小為 size 的大頂堆 */
        heap.remove(num[i]);
        heap.add(num[j]);
        ret.add(heap.peek());
    }
    return ret;
}
```

# 60. n 個骰子的點數

[Lintcode](https://www.lintcode.com/en/problem/dices-sum/)

## 題目描述

把 n 個骰子仍在地上，求點數和為 s 的概率。

<div align="center"> <img src="pics/6_2001550474388460.png"/> </div><br>

## 解題思路

### 動態規劃解法

使用一個二維數組 dp 存儲點數出現的次數，其中 dp[i][j] 表示前 i 個骰子產生點數 j 的次數。

空間復雜度：O(N<sup>2</sup>)

```java
public List<Map.Entry<Integer, Double>> dicesSum(int n) {
    final int face = 6;
    final int pointNum = face * n;
    long[][] dp = new long[n + 1][pointNum + 1];

    for (int i = 1; i <= face; i++)
        dp[1][i] = 1;

    for (int i = 2; i <= n; i++)
        for (int j = i; j <= pointNum; j++)     /* 使用 i 個骰子最小點數為 i */
            for (int k = 1; k <= face && k <= j; k++)
                dp[i][j] += dp[i - 1][j - k];

    final double totalNum = Math.pow(6, n);
    List<Map.Entry<Integer, Double>> ret = new ArrayList<>();
    for (int i = n; i <= pointNum; i++)
        ret.add(new AbstractMap.SimpleEntry<>(i, dp[n][i] / totalNum));

    return ret;
}
```

### 動態規劃解法 + 旋轉數組

空間復雜度：O(N)

```java
public List<Map.Entry<Integer, Double>> dicesSum(int n) {
    final int face = 6;
    final int pointNum = face * n;
    long[][] dp = new long[2][pointNum + 1];

    for (int i = 1; i <= face; i++)
        dp[0][i] = 1;

    int flag = 1;                                     /* 旋轉標記 */
    for (int i = 2; i <= n; i++, flag = 1 - flag) {
        for (int j = 0; j <= pointNum; j++)
            dp[flag][j] = 0;                          /* 旋轉數組清零 */

        for (int j = i; j <= pointNum; j++)
            for (int k = 1; k <= face && k <= j; k++)
                dp[flag][j] += dp[1 - flag][j - k];
    }

    final double totalNum = Math.pow(6, n);
    List<Map.Entry<Integer, Double>> ret = new ArrayList<>();
    for (int i = n; i <= pointNum; i++)
        ret.add(new AbstractMap.SimpleEntry<>(i, dp[1 - flag][i] / totalNum));

    return ret;
}
```

# 61. 撲克牌順子

[NowCoder](https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

五張牌，其中大小鬼為癩子，牌面大小為 0。判斷這五張牌是否能組成順子。

<div align="center"> <img src="pics/5_2001550474110029.png"/> </div><br>

## 解題思路

```java
public boolean isContinuous(int[] nums) {

    if (nums.length < 5)
        return false;

    Arrays.sort(nums);

    // 統計癩子數量
    int cnt = 0;
    for (int num : nums)
        if (num == 0)
            cnt++;

    // 使用癩子去補全不連續的順子
    for (int i = cnt; i < nums.length - 1; i++) {
        if (nums[i + 1] == nums[i])
            return false;
        cnt -= nums[i + 1] - nums[i] - 1;
    }

    return cnt >= 0;
}
```

# 62. 圓圈中最後剩下的數

[NowCoder](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

讓小朋友們圍成一個大圈。然後，隨機指定一個數 m，讓編號為 0 的小朋友開始報數。每次喊到 m-1 的那個小朋友要出列唱首歌，然後可以在禮品箱中任意的挑選禮物，並且不再回到圈中，從他的下一個小朋友開始，繼續 0...m-1 報數 .... 這樣下去 .... 直到剩下最後一個小朋友，可以不用表演。

## 解題思路

約瑟夫環，圓圈長度為 n 的解可以看成長度為 n-1 的解再加上報數的長度 m。因為是圓圈，所以最後需要對 n 取余。

```java
public int LastRemaining_Solution(int n, int m) {
    if (n == 0)     /* 特殊輸入的處理 */
        return -1;
    if (n == 1)     /* 遞歸返回條件 */
        return 0;
    return (LastRemaining_Solution(n - 1, m) + m) % n;
}
```

# 63. 股票的最大利潤

[Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)

## 題目描述

可以有一次買入和一次賣出，那麼買入必須在前。求最大收益。

<div align="center"> <img src="pics/4_2001550473915641.png"/> </div><br>

## 解題思路

使用貪心策略，假設第 i 輪進行賣出操作，買入操作價格應該在 i 之前並且價格最低。

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0)
        return 0;
    int soFarMin = prices[0];
    int maxProfit = 0;
    for (int i = 1; i < prices.length; i++) {
        soFarMin = Math.min(soFarMin, prices[i]);
        maxProfit = Math.max(maxProfit, prices[i] - soFarMin);
    }
    return maxProfit;
}
```

# 64. 求 1+2+3+...+n

[NowCoder](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=11200&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

要求不能使用乘除法、for、while、if、else、switch、case 等關鍵字及條件判斷語句 A ? B : C。

## 解題思路

使用遞歸解法最重要的是指定返回條件，但是本題無法直接使用 if 語句來指定返回條件。

條件與 && 具有短路原則，即在第一個條件語句為 false 的情況下不會去執行第二個條件語句。利用這一特性，將遞歸的返回條件取非然後作為 && 的第一個條件語句，遞歸的主體轉換為第二個條件語句，那麼當遞歸的返回條件為 true 的情況下就不會執行遞歸的主體部分，遞歸返回。

本題的遞歸返回條件為 n <= 0，取非後就是 n > 0；遞歸的主體部分為 sum += Sum_Solution(n - 1)，轉換為條件語句後就是 (sum += Sum_Solution(n - 1)) > 0。

```java
public int Sum_Solution(int n) {
    int sum = n;
    boolean b = (n > 0) && ((sum += Sum_Solution(n - 1)) > 0);
    return sum;
}
```

# 65. 不用加減乘除做加法

[NowCoder](https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tqId=11201&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

寫一個函數，求兩個整數之和，要求不得使用 +、-、\*、/ 四則運算符號。

## 解題思路

a ^ b 表示沒有考慮進位的情況下兩數的和，(a & b) << 1 就是進位。

遞歸會終止的原因是 (a & b) << 1 最右邊會多一個 0，那麼繼續遞歸，進位最右邊的 0 會慢慢增多，最後進位會變為 0，遞歸終止。

```java
public int Add(int a, int b) {
    return b == 0 ? a : Add(a ^ b, (a & b) << 1);
}
```

# 66. 構建乘積數組

[NowCoder](https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

給定一個數組 A[0, 1,..., n-1]，請構建一個數組 B[0, 1,..., n-1]，其中 B 中的元素 B[i]=A[0]\*A[1]\*...\*A[i-1]\*A[i+1]\*...\*A[n-1]。要求不能使用除法。

<div align="center"> <img src="pics/3_2001550473624627.png"/> </div><br>

## 解題思路

```java
public int[] multiply(int[] A) {
    int n = A.length;
    int[] B = new int[n];
    for (int i = 0, product = 1; i < n; product *= A[i], i++)       /* 從左往右累乘 */
        B[i] = product;
    for (int i = n - 1, product = 1; i >= 0; product *= A[i], i--)  /* 從右往左累乘 */
        B[i] *= product;
    return B;
}
```

# 67. 把字符串轉換成整數

[NowCoder](https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 題目描述

將一個字符串轉換成一個整數，字符串不是一個合法的數值則返回 0，要求不能使用字符串轉換整數的庫函數。

```html
Iuput:
+2147483647
1a33

Output:
2147483647
0
```

## 解題思路

```java
public int StrToInt(String str) {
    if (str == null || str.length() == 0)
        return 0;
    boolean isNegative = str.charAt(0) == '-';
    int ret = 0;
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (i == 0 && (c == '+' || c == '-'))  /* 符號判定 */
            continue;
        if (c < '0' || c > '9')                /* 非法輸入 */
            return 0;
        ret = ret * 10 + (c - '0');
    }
    return isNegative ? -ret : ret;
}
```

# 68. 樹中兩個節點的最低公共祖先

## 解題思路

### 二叉查找樹

<div align="center"> <img src="pics/293d2af9-de1d-403e-bed0-85d029383528.png" width="300"/> </div><br>

[Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

二叉查找樹中，兩個節點 p, q 的公共祖先 root 滿足 root.val >= p.val && root.val <= q.val。

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null)
        return root;
    if (root.val > p.val && root.val > q.val)
        return lowestCommonAncestor(root.left, p, q);
    if (root.val < p.val && root.val < q.val)
        return lowestCommonAncestor(root.right, p, q);
    return root;
}
```

### 普通二叉樹

<div align="center"> <img src="pics/37a72755-4890-4b42-9eab-b0084e0c54d9.png" width="300"/> </div><br>

[Leetcode : 236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

在左右子樹中查找是否存在 p 或者 q，如果 p 和 q 分別在兩個子樹中，那麼就說明根節點就是最低公共祖先。

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q)
        return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}
```

# 參考文獻

- 何海濤. 劍指 Offer[M]. 電子工業出版社, 2012.
